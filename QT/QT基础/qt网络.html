<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>连接示意图 | 我的笔记</title>
    <meta name="description" content="A VitePress Site">
    <meta name="generator" content="VitePress v1.2.3">
    <link rel="preload stylesheet" href="/Blog/assets/style.DWgdj8Vb.css" as="style">
    
    <script type="module" src="/Blog/assets/app.DbtwvcBi.js"></script>
    <link rel="preload" href="/Blog/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/Blog/assets/chunks/framework.Bt9cqVig.js">
    <link rel="modulepreload" href="/Blog/assets/chunks/theme.DBW91Qkw.js">
    <link rel="modulepreload" href="/Blog/assets/QT_QT基础_qt网络.md.CmrK3xzE.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar has-sidebar top" data-v-ae24b3ad data-v-ccf7ddec><div class="wrapper" data-v-ccf7ddec><div class="container" data-v-ccf7ddec><div class="title" data-v-ccf7ddec><div class="VPNavBarTitle has-sidebar" data-v-ccf7ddec data-v-ab179fa1><a class="title" href="/Blog/" data-v-ab179fa1><!--[--><!--]--><!----><span data-v-ab179fa1>我的笔记</span><!--[--><!--]--></a></div></div><div class="content" data-v-ccf7ddec><div class="content-body" data-v-ccf7ddec><!--[--><!--]--><div class="VPNavBarSearch search" data-v-ccf7ddec><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-ccf7ddec data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Blog/C++/OpenSSL.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>C++</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Blog/-.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>Python</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Blog/-.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>Go</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>QT</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link active" href="/Blog/QT/QT%E5%9F%BA%E7%A1%80/qt%E7%BD%91%E7%BB%9C.html" data-v-43f1e123><!--[-->QT基础<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link" href="/Blog/QT/QT%E4%BB%A3%E7%A0%81/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.html" data-v-43f1e123><!--[-->QT代码<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/Blog/Git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html" tabindex="0" data-v-7f418b0f data-v-9c663999><!--[--><span data-v-9c663999>Git</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-7f418b0f data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-b6c34ac9><span class="text" data-v-b6c34ac9><!----><span data-v-b6c34ac9>链接</span><span class="vpi-chevron-down text-icon" data-v-b6c34ac9></span></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><div class="items" data-v-e7ea1737><!--[--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link vp-external-link-icon" href="https://vitepress.dev/zh" target="_blank" rel="noreferrer" data-v-43f1e123><!--[-->vitepress官网<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link vp-external-link-icon" href="https://chat.openai.com/" target="_blank" rel="noreferrer" data-v-43f1e123><!--[-->OpenAi官网<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link vp-external-link-icon" href="https://leetcode.cn/problemset/" target="_blank" rel="noreferrer" data-v-43f1e123><!--[-->力扣官网<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link vp-external-link-icon" href="https://llfc.club/" target="_blank" rel="noreferrer" data-v-43f1e123><!--[-->恋恋风晨zack博客<!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-e7ea1737 data-v-43f1e123><a class="VPLink link vp-external-link-icon" href="https://godbolt.org/" target="_blank" rel="noreferrer" data-v-43f1e123><!--[-->Godbolt<!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-ccf7ddec data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-e6aabb21 data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-ccf7ddec data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Cookie330/Blog" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-ccf7ddec data-v-d0bd9dde data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-d0bd9dde><div class="item appearance" data-v-d0bd9dde><p class="label" data-v-d0bd9dde>Appearance</p><div class="appearance-action" data-v-d0bd9dde><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-d0bd9dde data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div></div></div><div class="group" data-v-d0bd9dde><div class="item social-links" data-v-d0bd9dde><div class="VPSocialLinks social-links-list" data-v-d0bd9dde data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Cookie330/Blog" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-ccf7ddec data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-ccf7ddec><div class="divider-line" data-v-ccf7ddec></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-17a5e62e><button data-v-17a5e62e>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-575e6a36><div class="curtain" data-v-575e6a36></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-575e6a36><span class="visually-hidden" id="sidebar-aria-label" data-v-575e6a36> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="group" data-v-575e6a36><section class="VPSidebarItem level-0 has-active" data-v-575e6a36 data-v-b8d55f3b><!----><div class="items" data-v-b8d55f3b><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/Blog/QT/QT%E5%9F%BA%E7%A1%80/qt%E7%BD%91%E7%BB%9C.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>QT网络</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/Blog/QT/QT%E5%9F%BA%E7%A1%80/QSS%E7%AC%94%E8%AE%B0.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>QSS笔记</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/Blog/QT/QT%E5%9F%BA%E7%A1%80/qt%E7%AA%97%E5%8F%A3.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>QT窗口</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/Blog/QT/QT%E5%9F%BA%E7%A1%80/qt%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>QT多线程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/Blog/QT/QT%E5%9F%BA%E7%A1%80/qt%E6%9C%BA%E5%88%B6.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>QT机制</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b8d55f3b data-v-b8d55f3b><div class="item" data-v-b8d55f3b><div class="indicator" data-v-b8d55f3b></div><a class="VPLink link link" href="/Blog/QT/QT%E5%9F%BA%E7%A1%80/qt%E7%B1%BB.html" data-v-b8d55f3b><!--[--><p class="text" data-v-b8d55f3b>QT类</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>页面导航</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _Blog_QT_QT%E5%9F%BA%E7%A1%80_qt%E7%BD%91%E7%BB%9C" data-v-39a288b8><div><h1 class="p1" id="连接示意图" tabindex="-1">连接示意图 <a class="header-anchor" href="#连接示意图" aria-label="Permalink to &quot;连接示意图{.p1}&quot;">​</a></h1><p><img src="/Blog/assets/image-20230802102546127.EWve0lMb.png" alt="image-20230802102546127"></p><h1 class="p1" id="qtcpserver" tabindex="-1">QTcpServer <a class="header-anchor" href="#qtcpserver" aria-label="Permalink to &quot;QTcpServer{.p1}&quot;">​</a></h1><p>QTcpServer类是QT中用于创建TCP服务器的类。它允许我们创建一个TCP服务器，监听客户端的连接，并与客户端进行通信。。</p><p>使用QTcpServer类的基本步骤如下：</p><ol><li>创建QTcpServer对象：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QTcpServer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QTcpServer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="2"><li>绑定服务器地址和端口：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QHostAddress</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;127.0.0.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 服务器地址</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">quint16 port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 12345</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 服务器端口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">listen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(address, port)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    qDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Failed to bind!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="3"><li>连接信号与槽：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SIGNAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newConnection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SLOT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleNewConnection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="4"><li>处理新连接： 在<code>handleNewConnection()</code>槽函数中，我们可以通过<code>nextPendingConnection()</code>函数获取新进来的连接：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleNewConnection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QTcpSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clientSocket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextPendingConnection</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 连接信号与槽</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(clientSocket, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SIGNAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readyRead</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SLOT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleReadyRead</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(clientSocket, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SIGNAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnected</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()), clientSocket, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SLOT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deleteLater</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="5"><li>处理客户端发送的数据： 在<code>handleReadyRead()</code>槽函数中，我们可以通过<code>readAll()</code>函数获取客户端发送的数据：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleReadyRead</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QTcpSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clientSocket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static_cast&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QTcpSocket</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QByteArray data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> clientSocket-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理接收到的数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="6"><li>向客户端发送数据：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">clientSocket-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ol start="7"><li>关闭服务器：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> server;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>除了以上基本用法，QTcpServer类还提供了其他一些有用的函数和信号，例如<code>error()</code>信号、<code>hasPendingConnections()</code>函数等，可以根据实际需求进行使用。</p><p>总结：QTcpServer类提供了建立TCP服务器的功能，并通过信号与槽机制来处理客户端连接、数据传输等操作。通过了解和掌握QTcpServer类的用法，我们可以方便地创建并管理TCP服务器应用程序。</p><h1 class="p1" id="qtcpsocket" tabindex="-1">QTcpSocket <a class="header-anchor" href="#qtcpsocket" aria-label="Permalink to &quot;QTcpSocket{.p1}&quot;">​</a></h1><p>在C++ Qt中，QTcpSocket类是用于实现TCP套接字通信的类。它继承自QAbstractSocket类，并且提供了一系列成员函数和成员变量来处理与TCP连接的相关操作。</p><p><strong>继承关系：</strong></p><ul><li>QTcpSocket类继承自QAbstractSocket类，而QAbstractSocket类则是继承自QObject类。这意味着QTcpSocket类继承了QObject类的信号和槽机制。</li><li>QTcpSocket类还间接继承自QIODevice类，让QTcpSocket对象可以像I/O设备一样读取和写入数据。</li></ul><p><strong>成员函数：</strong></p><p>QTcpSocket类包含了许多重要的成员函数。以下是其中一些常用的函数：</p><ul><li><code>connectToHost(const QString&amp; hostName, quint16 port)</code>: 连接到指定的主机名和端口号。</li><li><code>disconnectFromHost()</code>: 断开与远程主机的连接。</li><li><code>write(const char* data, qint64 size)</code>: 向连接的套接字写入指定大小的数据。</li><li><code>read(char* data, qint64 maxSize)</code>: 读取最多maxSize个字节到指定的data缓冲区。</li><li><code>flush()</code>: 强制刷新写入缓冲区。</li><li><code>waitForConnected(int msecs)</code>: 等待套接字与远程主机建立连接，最长等待时间为msecs毫秒。</li><li><code>state()</code>: 返回套接字的当前状态，如未连接、正在连接、已连接等。</li></ul><p>还有其他许多函数，用于管理套接字的选项、获取远程主机信息、处理错误等。</p><p><strong>成员变量：</strong></p><p>QTcpSocket类没有公共的成员变量。它提供了一些私有的成员变量来处理套接字连接和数据传输的状态信息，但这些信息对于一般用户是不可见的。</p><p><strong>常用API：</strong></p><ul><li><code>errorOccurred(QAbstractSocket::SocketError socketError)</code>信号：在发生套接字错误时发出。socketError参数指示错误的类型。</li><li><code>connected()</code>信号：当套接字成功连接到远程主机时发出。</li><li><code>disconnected()</code>信号：在套接字与远程主机断开连接时发出。</li><li><code>readyRead()</code>信号：当有数据可供读取时发出。</li></ul><p>此外，QTcpSocket还提供了许多其他API，包括与套接字缓冲区、超时设置和SSL支持相关的功能。</p><p>以上是关于C++ Qt中QTcpSocket类的继承、成员函数、成员变量和常用API的详细解释。希望对你有所帮助！</p><h3 id="在qtcpsocket中-我调用server-sock-connecttohost-qhostaddress-ip-port-我如何知道服务器连接上了" tabindex="-1">在QTcpSocket中 我调用server_sock_-&gt;connectToHost(QHostAddress(ip),port); 我如何知道服务器连接上了？ <a class="header-anchor" href="#在qtcpsocket中-我调用server-sock-connecttohost-qhostaddress-ip-port-我如何知道服务器连接上了" aria-label="Permalink to &quot;在QTcpSocket中 我调用server_sock_-&gt;connectToHost(QHostAddress(ip),port); 我如何知道服务器连接上了？&quot;">​</a></h3><p>在QTcpSocket中，当调用<code>connectToHost()</code>函数后，连接过程是异步的，意味着函数会立即返回，而不会等待连接完成。所以，要知道服务器是否成功连接，你需要关注以下两个方面：</p><ol><li>异步操作的结果信号：QTcpSocket类提供了一系列信号来通知连接状态的改变。你可以连接以下信号以获取连接的结果信息：</li></ol><ul><li><code>connected()</code>: 当连接成功时，会发出该信号。</li><li><code>errorOccurred(QAbstractSocket::SocketError)</code>: 当连接过程中发生错误时，会发出该信号，并传递错误码。</li></ul><p>你可以在连接<code>connectToHost()</code>函数之后，连接这些信号的槽函数，以获取连接状态的改变。</p><p>示例代码如下：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_sock_, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SIGNAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connected</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SLOT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onConnected</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()));</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_sock_, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SIGNAL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">errorOccurred</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QAbstractSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::SocketError)), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SLOT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QAbstractSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::SocketError)));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">server_sock_-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connectToHost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QHostAddress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ip), port);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>然后，你需要实现 <code>onConnected()</code> 和 <code>onError()</code> 槽函数，对连接结果进行处理。</p><ol start="2"><li>错误检查：在调用 <code>connectToHost()</code> 后，你可以检查返回值来判断连接是否成功。<code>connectToHost()</code> 函数返回一个布尔值，表示是否成功连接到服务器。如果返回 <code>true</code>，则连接成功；如果返回 <code>false</code>，则连接失败。</li></ol><p>示例代码如下：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(server_sock_-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connectToHost</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QHostAddress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ip), port))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 连接成功</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 连接失败</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>总结而言，你可以通过连接信号来监测连接结果。此外，如果你需要在连接后执行一些特定的操作，可以在槽函数中处理连接成功的情况。而对于连接失败的情况，则可以通过返回值进行判断。</p><h3 id="信号" tabindex="-1">信号 <a class="header-anchor" href="#信号" aria-label="Permalink to &quot;信号&quot;">​</a></h3><p>QTcpSocket类是Qt中用于实现TCP网络通信的类，它有许多信号用于通知应用程序网络通信的各种状态。下面是Qt中QTcpSocket类的一些常用信号的详细说明：</p><ol><li><p>connected()：当QTcpSocket成功连接到服务器时触发。可以用于通知应用程序连接已建立，并且可以开始进行数据传输。</p></li><li><p>disconnected()：当QTcpSocket与服务器的连接断开时触发。可以用于通知应用程序连接已经关闭。</p></li><li><p>error(QAbstractSocket::SocketError socketError)：当QTcpSocket发生错误时触发。socketError参数指示了发生的错误类型，可以根据不同的错误类型进行相应的处理。</p></li><li><p>stateChanged(QAbstractSocket::SocketState socketState)：当QTcpSocket的连接状态发生变化时触发。socketState参数指示了当前的连接状态，可以根据不同的状态进行相应的处理，如判断连接是否建立成功。</p></li><li><p>readyRead()：当QTcpSocket接收到新的数据时触发。可以用于通知应用程序有新的数据可用于读取。</p></li><li><p>bytesWritten(qint64 bytes)：当QTcpSocket成功发送数据时触发。bytes参数指示了成功发送的字节数。</p></li><li><p>aboutToClose()：在关闭连接之前触发。可以用于在断开连接之前做一些清理工作。</p></li></ol><p>以上是一些常用的QTcpSocket类的信号，根据具体的应用情况，还可以使用继承自QIODevice类的一些相关信号，例如readyRead()信号用于读取数据，bytesWritten()信号用于写入数据。在Qt的官方文档中有更详细的信号说明，可以进一步查阅。</p><h3 id="信号槽" tabindex="-1">信号槽 <a class="header-anchor" href="#信号槽" aria-label="Permalink to &quot;信号槽&quot;">​</a></h3><p>在Qt中，信号和槽是用于对象之间进行通信的机制。通过信号和槽，一个对象可以发射信号，另一个对象可以接收该信号并执行相应的槽函数。在Qt中，注册的信号槽的数量理论上是没有限制的，但实际上可能会受到一些因素的限制。</p><p>首先是内存的限制。每个信号和槽都需要在内存中存储相关的信息，包括信号和槽的名称、参数类型等。如果注册的信号槽过多，可能会导致内存占用过高，从而影响系统性能或引发内存不足的问题。</p><p>其次是处理能力的限制。当信号发射时，Qt会按照一定的顺序依次调用相应的槽函数。如果注册的信号槽过多，可能会导致处理能力不足，造成信号槽调用的延迟或不稳定性。</p><p>此外，还需要考虑代码维护的可读性和可维护性。注册过多的信号槽可能使代码变得复杂和难以理解，不利于代码的维护和调试。</p><p>因此，在实际开发中，我们应该谨慎地设计信号槽的数量，尽量避免注册过多的信号槽，以确保代码的性能和可维护性。</p><h1 class="p1" id="输入输出缓冲区" tabindex="-1">输入输出缓冲区 <a class="header-anchor" href="#输入输出缓冲区" aria-label="Permalink to &quot;输入输出缓冲区{.p1}&quot;">​</a></h1><p>在Qt中，QTcpServer和QTcpSocket是用于TCP服务器和TCP客户端的类。它们提供了TCP连接的功能并允许数据的传输。对于TCP连接，有相应的输入缓冲区和输出缓冲区。</p><p>TCP输出缓冲区： QTcpSocket类中的输出缓冲区是用来存储待发送的数据的地方。当调用QTcpSocket的write()方法发送数据时，数据会被写入输出缓冲区。输出缓冲区的大小是有限的，并且当缓冲区已满时，进一步的写操作将会被阻塞，直到有足够的空间来容纳更多数据。</p><p>要检查输出缓冲区的大小，可以使用socket的bytesToWrite()方法。此方法返回当前等待传输的字节数。当所有的数据都成功发送到远程主机后，输出缓冲区将会被清空。</p><p>TCP输入缓冲区： QTcpSocket类中的输入缓冲区是用来存储接收到的数据的地方。当远程主机发送数据到本地主机时，数据会被接收并存储在输入缓冲区中。可以使用socket的bytesAvailable()方法来检查输入缓冲区中的字节数。此方法返回当前可读取的字节数。</p><p>要读取输入缓冲区中的数据，可以使用socket的read()方法。此方法可以读取指定数量的字节数或所有的可用字节，以存储在指定的缓冲区中供进一步处理。</p><p>需要注意的是，输入缓冲区的大小是有限的，如果缓冲区已满且没有立即读取数据，新的数据将会被丢弃。</p><p>在进行TCP编程时，通常需要在适当的时间检查和处理缓冲区。常见的一种做法是使用readyRead()信号来实现异步读取输入缓冲区中的数据，并使用bytesWritten()信号来通知发送的数据已经从输出缓冲区中移除。这样可以确保在缓冲区的处理上有更好的控制，避免数据的丢失和阻塞的情况。</p><h1 class="p1" id="粘包" tabindex="-1">粘包 <a class="header-anchor" href="#粘包" aria-label="Permalink to &quot;粘包{.p1}&quot;">​</a></h1><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>自己的话说粘包  这个和TCP协议没有关系，是和我们程序员写的代码有关系。</span></span>
<span class="line"><span>TCP保证了数据按序到达。也就是你发送端调用send函数一次send了10个字节，经过网络传输，接收端就能从它的缓冲区里接收到这10个字节。粘包说白了就是发送端和接收端的速率不对等。 如发送端每个包是10个字节，这10个字节是一个信息，是一个完整的包。理想状态下，不考虑网络因素，假设发送端数据能瞬间到达接收端socket的读缓冲区。 接收端用while(1) 按10个字节来接收，得到这10个字节的信息，这样每次读取都能得到一个完整的包，这样并不会出现所谓的粘包。现实是发送端发得快，每组数据10个字节，也就是每个数据包是10个字节，但是由于网络的原因，并不是发送端一send完，包马上能到接收端的缓冲区，可能一共2个包一起到达接收端缓冲区，也可能是3个、4个，但是这些包包肯定是按send的顺序到的（TCP保证了）。如果接收端以while(1) 一直读取缓冲区每次读10个字节，也不会粘包，因为每个包就是10个字节，读一次就是一个包，这样即使考虑的网络也不会粘包。下面考虑一直粘包的情形。由于业务需要，发送端不可能固定每次10个字节。它第一次send10个字节，第二次send100个字节，第三四send200个字节，反正就是不固定。但是按包来读取 得到的信息才有意义 你接收方一次固定只读20个字节，就很可能从缓冲区里读到0.2个包 或者1个完整的包加上另一个包的二分之一，这样读到的数据是没用的，这就是所谓的粘包。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>你对粘包问题的理解基本上是正确的，但我会更详细地解释一些细节，以确保你完全理解这个概念。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>粘包是指在数据传输过程中，接收端收到的数据包不是按照发送端发送的完整数据包顺序进行接收，或者多个数据包在接收端被合并成一个大的数据块。这可能是由于网络传输的不稳定性，导致数据包的到达顺序或者数据包之间的间隔时间发生变化，从而引发数据接收的混乱。让我们逐步分析你的描述：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>1. **TCP的有序性：** 是的，TCP确保数据按序到达。发送端发送的数据包在网络中经过一系列的路由和中转，但接收端会按照发送的顺序将它们重新组装。这个特性确保了数据的顺序性。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>2. **发送端和接收端速率不对等：** 正是这种速率不对等导致了粘包问题。你的例子中，发送端发送的数据包大小不一，且由于网络传输的延迟，多个数据包可能在接收端的缓冲区中聚集，从而导致混乱。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>3. **理想状态下的情况：** 在你的理想情况下，确实不存在粘包问题。如果发送端发送的数据包恰好在接收端缓冲区内依次到达，而接收端按照恰好的包大小进行读取，那么是不会出现粘包问题的。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>4. **实际粘包情形：** 现实中，网络传输有延迟，数据包可能一起到达。即使这些数据包按照顺序到达，但由于接收端的读取时机不确定，就可能导致数据包被合并，形成粘包现象。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>5. **不固定的发送包大小：** 当发送端发送的数据包大小不固定时，接收端需要动态地处理不同大小的数据包。在接收端使用固定大小的缓冲区来接收数据时，就可能导致粘包问题。如果一个大数据包到达，它可能会覆盖部分缓冲区，使后续数据包被合并。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>解决粘包问题的方法通常包括：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- **消息边界：** 在发送数据时，可以在每个数据包前面添加一个长度字段，表示该数据包的长度，接收端首先读取长度字段，然后按照长度读取相应大小的数据，从而确保每个数据包都能被正确解析。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- **定长包：** 可以将每个数据包固定为一个特定的长度，在接收端按照这个长度进行读取，即使粘包发生，也不会影响解析。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>- **分隔符：** 在数据包之间添加特定的分隔符，接收端根据分隔符来分割数据包。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>总之，粘包是在网络传输中常见的问题，特别是在数据包大小不固定且网络传输不稳定的情况下。采取适当的解决方案可以有效地应对这个问题。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>在Qt的网络编程中，TCP协议可以面临粘包问题。粘包问题是指在网络通信中，发送方将多次发送的数据包合并成一个大的数据包，而接收方无法正确地分辨出各个数据包的边界，导致数据处理的混乱。</p><p>原因：</p><ol><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li></li><li>数据在网络传输过程中会受到网络拥塞、传输速度不同等因素的影响，可能导致数据包的接收和发送时间不一致。</li><li>操作系统的TCP协议栈会对发送的数据进行优化和缓存，造成发送方连续发送的数据被合并在一起。</li></ol><p>解决方法：</p><ol><li>定长数据包：发送方和接收方都按照固定长度的数据包进行发送和接收。接收方按照固定长度的数据进行切割处理。</li><li>分隔符：发送方在每个数据包的末尾添加特定的分隔符，接收方根据分隔符将接收到的数据进行切割。</li><li>长度字段：发送方在每个数据包的前面添加表示数据长度的字段，接收方首先读取长度字段，在知道了数据长度后按照长度进行切割。</li><li>使用消息头：在每个数据包之前，添加一个消息头，消息头包含了消息的元信息，比如数据长度、类型等。</li></ol><p>在Qt中，可以结合以上方法来解决粘包问题。根据具体的应用场景和需求，选择合适的方法来确保数据的可靠传输和正确处理。此外，Qt提供了QDataStream类来辅助数据的序列化和反序列化，可以简化数据包的处理过程。</p><h2 id="tcp缓冲区满了会怎么样" tabindex="-1">TCP缓冲区满了会怎么样 <a class="header-anchor" href="#tcp缓冲区满了会怎么样" aria-label="Permalink to &quot;TCP缓冲区满了会怎么样&quot;">​</a></h2><p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输协议，通常被用于互联网中的数据传输。它通过使用缓冲区，将数据分段发送，从而保证了数据的传输过程中的可靠性。</p><p>不过，当TCP的缓冲区被塞满时，会发生什么呢？下面我们来了解一下。</p><h2 id="缓冲区满了意味着什么" tabindex="-1">缓冲区满了意味着什么 <a class="header-anchor" href="#缓冲区满了意味着什么" aria-label="Permalink to &quot;缓冲区满了意味着什么&quot;">​</a></h2><p>TCP的缓冲区是一个用于存储数据的内存区域，在数据传输过程中起到了很重要的作用。缓冲区的大小对TCP的传输速度以及防止数据丢失的能力有着直接的影响。</p><p>当数据到达TCP的接收端时，TCP会将数据保存在缓冲区中，等待接收端进程从缓冲区取出数据并进行处理。如果缓冲区满了，TCP会停止接收新的数据，直到缓冲区腾出空间来。</p><p>缓冲区满了，则说明数据传输的速度快于接收方的处理速度，当发送端继续发送数据时，数据将不得不等待直到缓冲区有足够的空间。这种情况下，数据传输的速度下降，影响了TCP的传输效率。</p><h2 id="缓冲区满了会导致什么问题" tabindex="-1">缓冲区满了会导致什么问题 <a class="header-anchor" href="#缓冲区满了会导致什么问题" aria-label="Permalink to &quot;缓冲区满了会导致什么问题&quot;">​</a></h2><p>当TCP的缓冲区被塞满时，会导致以下几个问题：</p><h3 id="_1-流量控制失效" tabindex="-1">1.流量控制失效 <a class="header-anchor" href="#_1-流量控制失效" aria-label="Permalink to &quot;1.流量控制失效&quot;">​</a></h3><p>当TCP的缓冲区满了，发送方会不断重复发送数据，从而导致接收方需要不断地将已经接收了的数据进行丢弃。这种情况就会导致流量控制失效。</p><h3 id="_2-拥塞控制失效" tabindex="-1">2.拥塞控制失效 <a class="header-anchor" href="#_2-拥塞控制失效" aria-label="Permalink to &quot;2.拥塞控制失效&quot;">​</a></h3><p>当TCP发送方发送的数据包速度超过接收方的处理速度时，会导致网络出现拥塞。此时，TCP需要通过拥塞控制机制来控制发送速度，防止网络拥塞恶化。但当缓冲区满了时，TCP无法获得当前网络的实际拥塞情况，就会导致拥塞控制失效。</p><h3 id="_3-数据丢失概率增大" tabindex="-1">3.数据丢失概率增大 <a class="header-anchor" href="#_3-数据丢失概率增大" aria-label="Permalink to &quot;3.数据丢失概率增大&quot;">​</a></h3><p>当发送方发送的数据包数量超过了接收方的处理速度，这些数据包就会被保存在缓冲区中，直到接收方处理完这些数据。但是，当缓冲区已经满了，TCP就需要丢弃一部分当前已经保存在缓冲区中的数据。这种情况下，已经发送但还没有被处理的数据包会被丢失，从而导致数据传输的不可靠性。</p><h2 id="如何避免缓冲区满" tabindex="-1">如何避免缓冲区满 <a class="header-anchor" href="#如何避免缓冲区满" aria-label="Permalink to &quot;如何避免缓冲区满&quot;">​</a></h2><p>为了避免TCP的缓冲区被塞满，我们可以采取以下措施：</p><h3 id="_1-增加缓冲区的大小" tabindex="-1">1.增加缓冲区的大小 <a class="header-anchor" href="#_1-增加缓冲区的大小" aria-label="Permalink to &quot;1.增加缓冲区的大小&quot;">​</a></h3><p>当TCP的缓冲区的大小较小时，会导致缓冲区容易被填满。为了避免缓冲区溢出，可以通过增加缓冲区的大小，从而提高TCP传输效率。</p><h3 id="_2-优化应用程序" tabindex="-1">2.优化应用程序 <a class="header-anchor" href="#_2-优化应用程序" aria-label="Permalink to &quot;2.优化应用程序&quot;">​</a></h3><p>当应用程序处理数据速度较慢时，会导致TCP的缓冲区溢出。因此，我们可以通过对应用程序进行优化，从而提高数据处理速度，避免TCP的缓冲区溢出。</p><h3 id="_3-使用多线程" tabindex="-1">3.使用多线程 <a class="header-anchor" href="#_3-使用多线程" aria-label="Permalink to &quot;3.使用多线程&quot;">​</a></h3><p>当单一线程处理TCP的数据时，容易导致TCP的缓冲区被塞满。为了解决这个问题，我们可以考虑使用多线程来处理TCP的数据，从而提高TCP的传输效率。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>TCP的缓冲区被塞满时，会影响TCP的传输效率以及传输的可靠性。为了避免TCP的缓冲区被塞满，我们可以采取一系列措施，如增加缓冲区的大小、优化应用程序以及使用多线程等。这样，可以提高TCP的传输效率，避免数据传输的不可靠性。</p><h3 id="qt中的粘包处理代码" tabindex="-1">QT中的粘包处理代码 <a class="header-anchor" href="#qt中的粘包处理代码" aria-label="Permalink to &quot;QT中的粘包处理代码&quot;">​</a></h3><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">///***********************服务端****************************</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//防止粘包处理  处理//先发包头 再发包体  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//大于2个字节才读 因为前2个字节被用来存储包信息作为包头   记录数据长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //小于2个字节 说明缓冲区里没有一个完整的包</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bytesAvailable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//有包 就解析包</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //读两个字节 就是包头</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        QByteArray head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        QDataStream </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">head,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QIODevice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::ReadOnly);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        out </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        QByteArray data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(len);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        qDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ui-&gt;messageBox-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">objectName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;说: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//处理完整包</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bytesAvailable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    qDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;current_client_sock-&gt;bytesAvailable():&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bytesAvailable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QByteArray head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QDataStream </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">head,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QIODevice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::ReadOnly);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    out </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QByteArray data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(len);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    qDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ui-&gt;messageBox-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">append</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(current_client_sock-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">objectName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;说: &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">///************************客户端****************************</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//先发包头 再发包体  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//但是这样如果发包频繁时， 包头作为小包 会频繁的被发送 </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//网络拥塞： 大量小包的频繁发送可能导致网络拥塞，因为网络会花费更多的时间在处理包头、传输控制等方面，而不是实际数据传输。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//带宽利用不高： 小包通常会浪费带宽，因为在每个包的开销中，实际传输的数据占比较小。这可能导致网络带宽得不到充分利用。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//延迟增加： 由于小包的数量增多，可能导致整体通信的延迟增加，因为每个小包的处理时间和传输时间都会有一定开销。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//TCP头开销： 每个TCP包都有一些额外的开销，如序列号、确认号等，对于小包而言，这种开销相对较大，进一步增加了总体开销。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QByteArray head;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">head.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QDataStream</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QIODevice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">WriteOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">in </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> msg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">client_sock_-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(head);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">client_sock_-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(msg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUtf8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//或者拼一起发出去</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> msg.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUtf8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">size_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> request_length </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strlen</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(request);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> send_data[MAX_LENGTH] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memcpy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(send_data, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">request_length, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">memcpy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(send_data </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, request, request_length);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//    qDebug()&lt;&lt; QByteArray(send_data);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    client_sock_-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(send_data, request_length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br></div></div><h3 id="客户端-加包头处理粘包" tabindex="-1">客户端：加包头处理粘包 <a class="header-anchor" href="#客户端-加包头处理粘包" aria-label="Permalink to &quot;客户端：加包头处理粘包&quot;">​</a></h3><p><img src="/Blog/assets/image-20230803160414996.BNFJpxnN.png" alt="image-20230803160414996"></p><p><img src="/Blog/assets/image-20230803160445482.B0rtKNC-.png" alt="image-20230803160445482"></p><h3 id="服务端-接收带包头的数据包" tabindex="-1">服务端：接收带包头的数据包 <a class="header-anchor" href="#服务端-接收带包头的数据包" aria-label="Permalink to &quot;服务端：接收带包头的数据包&quot;">​</a></h3><p><img src="/Blog/assets/image-20230803161709554.CeyJH5-W.png" alt="image-20230803161709554"></p><p><img src="/Blog/assets/image-20230803162533089.Ch0rVkch.png" alt="image-20230803162533089"></p><p>按包发送 tcp保证这个包可以按序到达 服务端也要按包接收</p><p>你一次发100个包 就是write() 100次 服务端触发readyRead后 可能缓冲区到了50个包 也可能到了20个包</p><p>这时调用readAll 可以全部读出来 全读到一个QByteArray里 但是</p><h1 class="p1" id="tcp协议" tabindex="-1">TCP协议 <a class="header-anchor" href="#tcp协议" aria-label="Permalink to &quot;TCP协议{.p1}&quot;">​</a></h1><h2 id="发送方多次发送数据包-用来传递-helloworld-这个字符串-请问由tcp协议-接收方一定能按序接收吗" tabindex="-1">发送方多次发送数据包 用来传递&quot;helloworld&quot;这个字符串，请问由TCP协议，接收方一定能按序接收吗 <a class="header-anchor" href="#发送方多次发送数据包-用来传递-helloworld-这个字符串-请问由tcp协议-接收方一定能按序接收吗" aria-label="Permalink to &quot;发送方多次发送数据包 用来传递&quot;helloworld&quot;这个字符串，请问由TCP协议，接收方一定能按序接收吗&quot;">​</a></h2><p>根据TCP协议的特性，TCP连接上的数据传输是可靠的、有序的。因此，在正常的网络环境下，发送方多次发送数据包以传递&quot;helloworld&quot;这个字符串，接收方应该能够按序接收。</p><p>TCP协议保证了数据的可靠性和有序性，它使用了一些机制来确保数据的正确传输：</p><ol><li>确认应答机制：接收方在接收到数据后会发送确认应答给发送方，告知发送方数据已接收。发送方会等待接收到确认应答后才会发送下一个数据包，确保数据的正确传输。</li><li>序列号：每个TCP数据包都带有一个序列号，接收方根据序列号对接收到的数据包进行排序，以保证数据的有序性。</li><li>滑动窗口：发送方和接收方都有一个滑动窗口的概念。发送方的滑动窗口大小表示可以发送的数据的数量，而接收方的滑动窗口大小表示可以接收的数据的数量。滑动窗口的大小会根据网络状况动态调整，以实现流量控制和拥塞控制。</li></ol><p>虽然TCP协议保证了数据的有序性，但在某些情况下，仍可能发生乱序的情况：</p><ol><li>网络延迟：如果网络延迟很高，数据包到达接收方的顺序可能会与发送顺序不一致。</li><li>多路径传输：如果数据包通过不同的路径传输，可能会导致数据包乱序。</li></ol><p>对于接收方来说，可以通过TCP的接收缓冲区对乱序的数据包进行排序。接收缓冲区会根据序列号对接收到的数据进行排序，以确保数据的有序性。接收方可以通过read()方法从接收缓冲区中按序读取数据。</p><p>总而言之，在正常的网络环境下，TCP协议可以保证接收方按序接收数据，但在特殊情况下仍可能发生乱序的情况，接收方可以使用接收缓冲区进行数据的排序和处理。</p><h2 id="你说的-接收方可以使用接收缓冲区进行数据的排序和处理。-中-这个接收缓冲区是操作系统控制的-我好像不能操作吧" tabindex="-1">你说的“接收方可以使用接收缓冲区进行数据的排序和处理。”中，这个接收缓冲区是操作系统控制的，我好像不能操作吧 <a class="header-anchor" href="#你说的-接收方可以使用接收缓冲区进行数据的排序和处理。-中-这个接收缓冲区是操作系统控制的-我好像不能操作吧" aria-label="Permalink to &quot;你说的“接收方可以使用接收缓冲区进行数据的排序和处理。”中，这个接收缓冲区是操作系统控制的，我好像不能操作吧&quot;">​</a></h2><p>是的，接收缓冲区通常是由操作系统控制和管理的，对于应用程序来说是不可直接操作的。接收缓冲区位于操作系统内核中，用于接收和存储网络数据包。应用程序通过套接字API（如Qt的QTcpSocket类）与操作系统进行交互，而不直接访问接收缓冲区。</p><p>当接收方从TCP连接中读取数据时，操作系统会将接收到的数据包存储在接收缓冲区中。应用程序通过套接字API的读取方法（如QTcpSocket的read()方法）从接收缓冲区中读取数据。这个读取方法返回的是在接收缓冲区中按序存储的接收到的数据。</p><p>操作系统的接收缓冲区通常具有一定的容量限制。当接收缓冲区已满时，新的接收数据包将被丢弃。此时，TCP协议的滑动窗口机制会将此情况通知发送方，让发送方减少发送速率，以避免数据丢失和网络拥塞。</p><p>尽管应用程序无法直接操作接收缓冲区，但它可以通过设置套接字的接收缓冲区大小来间接影响操作系统的缓冲区。在Qt中，可以使用QTcpSocket的setSocketOption()方法来设置接收缓冲区的大小。</p><p>总结起来，接收缓冲区是由操作系统控制和管理的，应用程序无法直接操作它，但可以通过设置套接字的选项来间接影响缓冲区的大小。应用程序可以使用套接字API读取接收缓冲区中的数据。</p><h2 id="qtcpsocket-clientsocket-qobject-cast-qtcpsocket-sender" tabindex="-1">QTcpSocket* clientSocket = qobject_cast&lt;QTcpSocket*&gt;(sender()); <a class="header-anchor" href="#qtcpsocket-clientsocket-qobject-cast-qtcpsocket-sender" aria-label="Permalink to &quot;QTcpSocket* clientSocket = qobject_cast&lt;QTcpSocket*&gt;(sender());&quot;">​</a></h2><p>这段代码是使用Qt框架中的qobject_cast函数进行类型转换。该函数用于在运行时将QObject类型的指针转换为指定类型的指针。</p><p>在这里，代码中的sender()函数返回的是一个指向发送信号的对象的指针（即发送者）。假设发送该信号的对象是一个QTcpSocket类型的对象。</p><p>代码中，调用qobject_cast&lt;QTcpSocket*&gt;(sender())将sender()返回的QObject类型的指针转换为QTcpSocket类型的指针，赋值给clientSocket变量。</p><p>这个转换的目的是为了方便使用与QTcpSocket相关的功能和属性。如果转换成功，clientSocket变量将指向发送信号的对象，而且可以通过该指针来访问和操作该对象的成员函数和成员变量。</p><p>需要注意的是，qobject_cast的转换是安全的，如果无法进行转换（例如，sender()返回的对象并不是QTcpSocket类型的对象），则返回一个空指针。所以在使用clientSocket之前，应该进行空指针检查。</p><h2 id="在用cpp的qt的qtcpsocket编程中如果服务端socket连接上了多个客户端socket-服务器分别对他们发数据时-这些客户端socket是共用服务端的输出缓冲区吗" tabindex="-1">在用cpp的qt的QTcpSocket编程中如果服务端socket连接上了多个客户端socket，服务器分别对他们发数据时，这些客户端socket是共用服务端的输出缓冲区吗 <a class="header-anchor" href="#在用cpp的qt的qtcpsocket编程中如果服务端socket连接上了多个客户端socket-服务器分别对他们发数据时-这些客户端socket是共用服务端的输出缓冲区吗" aria-label="Permalink to &quot;在用cpp的qt的QTcpSocket编程中如果服务端socket连接上了多个客户端socket，服务器分别对他们发数据时，这些客户端socket是共用服务端的输出缓冲区吗&quot;">​</a></h2><p>在使用Qt的QTcpSocket编程中，服务端的QTcpSocket对象是独立于每个客户端的。所以当多个客户端连接到服务端时，每个客户端有自己独立的输出缓冲区。</p><p>当服务端发送数据给客户端时，通过write()函数将数据写入每个客户端的输出缓冲区。这些数据将由操作系统协议栈发送到对应的客户端。</p><p>服务端的输出缓冲区是以客户端为单位进行管理的，每个客户端连接的QTcpSocket对象都有自己的输出缓冲区。这意味着当服务端向一个客户端发送数据时，不会影响其他连接的客户端的输出缓冲区。</p><p>每个QTcpSocket对象可以通过相关的函数如write()、flush()来控制自己的输出缓冲区。可以通过QAbstractSocket类中的一些信号和槽，如bytesWritten()信号和bytesToWrite()函数来获取和监控输出缓冲区中的数据量。</p><p>综上所述，在Qt的QTcpSocket编程中，服务端和客户端之间的连接是独立的，每个客户端都有自己独立的输出缓冲区，服务端发送数据时不会影响其他连接的客户端的输出缓冲区。</p><h1 class="p1" id="udp协议" tabindex="-1">UDP协议 <a class="header-anchor" href="#udp协议" aria-label="Permalink to &quot;UDP协议{.p1}&quot;">​</a></h1><h3 id="udp组播是什么意思-为什么要用组播-什么时候用组播" tabindex="-1">udp组播是什么意思 为什么要用组播 什么时候用组播 <a class="header-anchor" href="#udp组播是什么意思-为什么要用组播-什么时候用组播" aria-label="Permalink to &quot;udp组播是什么意思 为什么要用组播 什么时候用组播&quot;">​</a></h3><p><strong>只有UDP才有广播、组播的传递方式</strong></p><p><strong>多播的重点是高效的把同一个包尽可能多的发送到不同的，甚至可能是未知的设备</strong></p><p><strong>但是TCP连接是一对一明确的，只能单播。</strong></p><p>UDP组播（UDP Multicast）是一种网络通信模式，用于在单个发送者将数据发送到多个接收者的情况下，有效地传输数据。UDP组播使用组播IP地址，将数据发送到一组特定的目标接收者，这些接收者通过加入组播组来表明对这些数据感兴趣。</p><p>以下是关于UDP组播的详细解释以及为什么要使用它的原因：</p><p><strong>1. UDP组播的概念：</strong></p><ul><li><p><strong>组播组：</strong> 组播通信基于组播组的概念。组播组是一组主机的逻辑集合，这些主机对同一组播组共享兴趣。<strong>每个组播组都有一个唯一的组播IP地址</strong>，通常属于IPv4地址范围的特殊范围（例如，224.0.0.0到239.255.255.255）。</p></li><li><p><strong>发送者：</strong> 发送者是将数据发送到组播组的主机。它使用组播IP地址来标识目标组。</p></li><li><p><strong>接收者：</strong> 接收者是对特定组播组感兴趣的主机。它们通过加入组播组来表明他们希望接收来自该组的数据。</p></li><li><p><strong>路由器：</strong> 路由器在网络中传递组播数据包，确保它们只被发送到加入了相应组的主机。</p></li></ul><p><strong>2. 为什么要使用UDP组播：</strong></p><ul><li><p><strong>节省带宽：</strong> UDP组播允许数据仅发送一次，但可以被多个接收者共享。这节省了网络带宽，因为数据不会被多次复制传输，而是仅传输一次。</p></li><li><p><strong>降低负载：</strong> 对于一对多或多对多通信，使用单播（Unicast）可能会导致发送者的负载增加，因为它必须向每个接收者发送独立的数据流。使用UDP组播可以降低发送者的负载。</p></li><li><p><strong>实时通信：</strong> UDP组播非常适合实时通信应用，如视频流、音频流以及在线游戏，因为它可以减少延迟并提供高效的数据传输。</p></li></ul><p><strong>3. 什么时候使用UDP组播：</strong></p><p>UDP组播适用于以下情况：</p><ul><li><p><strong>多播通信需求：</strong> 当需要将数据同时发送给多个接收者，并且这些接收者共享相同的兴趣或需要相同的数据时，UDP组播是一个合适的选择。</p></li><li><p><strong>实时数据传输：</strong> 当需要实时传输数据（如实时音视频流、传感器数据等）时，UDP组播通常比传统的单播方式更适合，因为它可以降低延迟。</p></li><li><p><strong>广播：</strong> 在某些情况下，UDP组播可以用作广播的替代方案，以提供更高效的广播通信。</p></li></ul><p>需要注意的是，UDP组播在Internet上的使用可能受到网络配置和路由器支持的限制。在局域网（LAN）环境中，UDP组播通常更容易实现和管理。在互联网上使用UDP组播通常需要更多的配置和注意事项。因此，在决定是否使用UDP组播时，应根据具体的应用需求和网络环境来进行评估和决策。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>在局域网中，当一台计算机发送UDP组播数据包到组播组地址&quot;192.168.2.250&quot;时，路由器需要具备组播路由支持，以便正确转发数据包给所有监听该组播组的电脑。以下是详细的工作原理：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>发送UDP组播数据包： 发送方的计算机使用UDP套接字将数据包发送到目标组播组地址&quot;192.168.2.250&quot;和端口9999。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>路由器的组播路由支持： 路由器必须支持IGMP（Internet Group Management Protocol）或其他组播协议，以便了解哪些局域网中的计算机已经加入了特定的组播组。IGMP是一种常见的组播管理协议，用于在局域网内管理组播组成员。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>组播组成员维护： 当计算机加入组播组&quot;192.168.2.250&quot;时，它会发送IGMP成员报告到路由器，通知路由器它对该组播组感兴趣。路由器会记录这些信息，知道哪些计算机在该组播组上注册了兴趣。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>路由器的数据包转发： 当发送方计算机发送UDP组播数据包到&quot;192.168.2.250&quot;时，路由器会检查其组播路由表，查看哪些接口上有成员对该组播组感兴趣。路由器会将数据包复制并发送到所有对该组播组感兴趣的接口，以确保所有成员都能够接收到数据包。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>接收端计算机的处理： 局域网中所有监听组播组&quot;192.168.2.250&quot;的计算机都会接收到发送的数据包。它们会通过监听的端口（9999）来接收数据，并处理数据包中的内容。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>总结一下，路由器在组播路由支持的情况下，会根据组播路由表将组播数据包复制并发送到所有对该组播组感兴趣的局域网接口。这样，所有监听相同组播组的计算机都能够接收到发送的数据包，从而实现了UDP组播。路由器使用IGMP等协议来维护组播组成员的信息，以确保数据包被正确转发。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="广播-组播-多播" tabindex="-1">广播 组播 多播 <a class="header-anchor" href="#广播-组播-多播" aria-label="Permalink to &quot;广播 组播 多播&quot;">​</a></h3><p>多播（Multicast），组播（Broadcast）和广播（Broadcast）是网络通信中的三种不同方式，它们在目标接收者和数据包传递方面有重要区别。以下是它们的详细区别：</p><ol><li><p><strong>广播（Broadcast）</strong>：</p><ul><li><strong>目标</strong>：广播发送的数据包被发送到网络中的所有设备，无论它们是否感兴趣。</li><li><strong>范围</strong>：广播消息在整个网络中传播，包括子网内的所有设备。</li><li><strong>示例</strong>：ARP（地址解析协议）广播是一个常见的示例，用于查找给定IP地址的MAC地址。在ARP广播中，数据包发送到所有设备，然后只有具有匹配IP地址的设备响应。</li></ul></li><li><p><strong>组播（Multicast）</strong>：</p><ul><li><strong>目标</strong>：组播发送的数据包仅被发送到已加入特定组播组的设备。</li><li><strong>范围</strong>：组播消息仅在加入了相同组播组的设备之间传播。</li><li><strong>示例</strong>：在视频流传输中，可以使用组播来将视频流发送到仅对该流感兴趣的接收者，而不是整个网络中的所有设备。</li></ul></li><li><p><strong>多播（Unicast）</strong>：</p><ul><li><strong>目标</strong>：多播发送的数据包被发送到一个特定的目标设备。</li><li><strong>范围</strong>：多播消息是一对一的通信，只与一个设备有关。</li><li><strong>示例</strong>：常见的网络通信模式，例如HTTP请求，是多播通信。一个客户端发送HTTP请求到特定的服务器，而服务器发送响应只给这个特定的客户端。</li></ul></li></ol><p>综上所述，广播发送数据包到整个网络中的所有设备，组播发送数据包到特定的组播组中的设备，而多播是一对一的通信，只涉及发送和接收双方。这些不同的通信方式在网络中的使用场景和效率方面都有不同的优势。多播通常用于流媒体和一对多通信，而广播在一些特殊情况下使用，而多播是一对一通信的常见方式。</p><h1 class="p1" id="qtcpsocket读数据api" tabindex="-1">QTcpSocket读数据api <a class="header-anchor" href="#qtcpsocket读数据api" aria-label="Permalink to &quot;QTcpSocket读数据api{.p1}&quot;">​</a></h1><p>在Qt中，QTcpSocket类提供了多个读取数据的API，如下所示：</p><ol><li><p><code>readLine()</code>: 这个函数用于从套接字中读取一行数据。它会一直读取，直到遇到换行符（<code>\n</code>）或者回车符（<code>\r</code>）为止，并返回读取到的数据。</p></li><li><p><code>readAll()</code>: 这个函数用于读取套接字中的所有可用数据，并以字节数组的形式返回。它不考虑数据的结构，而是将所有可用的数据一次性读取出来。</p></li><li><p><code>read(n)</code>: 这个函数用于从套接字中读取指定数量（n）的字节，并以字节数组的形式返回。它可以用于读取任意长度的数据。</p></li><li><p><code>readData(n)</code>: 这个函数与<code>read(n)</code>类似，用于读取指定数量（n）的字节，并以字节数组的形式返回。这个函数是虚函数，可以在派生类中进行重写，以实现自定义的读取逻辑。</p></li></ol><p>这些函数在读取数据时具有一些区别：</p><ul><li><code>readLine()</code> 只返回一行数据，并且会包含换行符（<code>\n</code>）或者回车符（<code>\r</code>）。</li><li><code>readAll()</code> 会一次性读取套接字中的所有可用数据，不管数据的结构，适用于已知数据长度或非结构化数据。</li><li><code>read(n)</code> 允许读取指定数量的字节，适用于读取特定长度的数据。</li><li><code>readData(n)</code> 是一个虚函数，可以在派生类中自定义实现，以满足特定的读取需求。</li></ul><p>请注意，这些函数都是阻塞的，调用它们会导致程序在读取数据时暂停执行，直到完成读取操作或达到超时。如果你希望在不阻塞程序运行的情况下读取数据，可以考虑使用信号和槽机制或者在另一个线程中执行读取操作。</p><h1 class="p1" id="qtcpsocket写数据api" tabindex="-1">QTcpSocket写数据api <a class="header-anchor" href="#qtcpsocket写数据api" aria-label="Permalink to &quot;QTcpSocket写数据api{.p1}&quot;">​</a></h1><p>在Qt中，QTcpSocket类提供了多个写入数据的API，如下所示：</p><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">qint64</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">qint64</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> maxSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这个函数用于将指定的数据写入套接字。传入的参数可以是字节数组（QByteArray）、字符串（QString）或者字符数组（const char*）。它会将数据写入套接字的发送缓冲区。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这个方法用于写入二进制数据到套接字。参数data是一个指向要发送数据的字符数组的指针，maxSize是要发送的最大字节数。这个方法返回实际写入的字节数，如果写入失败则返回-1。 这个方法是同步的，也就是说在数据被完全写入之前，这个方法将阻塞当前线程。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> putChar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这个函数用于向套接字写入一个字符。传入的参数是一个字符（QChar）。这个方法用于写入一个字符到套接字。参数c是要发送的字符。 这个方法是同步的，也就是说在字符被完全写入之前，这个方法将阻塞当前线程。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><div class="language-c++ vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">c++</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">virtual</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> qint64</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> writeData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">qint64</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> maxSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这个函数与`write(data)`类似，用于将指定大小的数据写入套接字的发送缓冲区。这个函数是虚函数，可以在派生类中进行重写，以实现自定义的写入逻辑。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这是一个虚函数，用于写入二进制数据到套接字。参数data是一个指向要发送数据的字符数组的指针，maxSize是要发送的最大字节数。这个方法返回实际写入的字节数，如果写入失败则返回-1。 这个方法是同步的，也就是说在数据被完全写入之前，这个方法将阻塞当前线程。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>总的来说，这些写数据的方法都是同步的，它们会阻塞当前线程直到数据被完全写入。如果你想要异步写入数据，你可以考虑使用信号和槽机制，在数据写入完成后触发一个信号来通知应用程序。或者你也可以将写操作放在单独的线程中进行，以便不阻塞主线程的执行。</p><p>这些函数在写入数据时有一些区别：</p><ul><li><code>write(data)</code> 可以一次性写入任意长度的数据，适用于写入已知长度的数据（字节数组、字符串等）。</li><li><code>putChar(ch)</code> 可以一次写入一个字符，适用于逐个字符地写入数据。</li><li><code>writeData(data, size)</code> 允许一次性写入指定大小的数据，适用于自定义写入逻辑的场景。</li></ul><p>需要注意的是，这些函数会将数据写入套接字的发送缓冲区，并不保证实际发送到对端。要确保数据被成功发送，可以结合使用<code>waitForBytesWritten()</code> 函数来等待发送操作完成，或者使用信号和槽机制来进行异步操作。</p><p>此外，QTcpSocket还提供了<code>flush()</code>函数，用于<strong>强制将发送缓冲区的数据立即写入套接字</strong>。这在某些情况下可以确保数据及时发送出去，而不是等待缓冲区填满。</p><h3 id="强制将发送缓冲区的数据立即写入套接字-是什么意思-写入套接字不就是写入套接字对应的发送缓冲区吗" tabindex="-1">“强制将发送缓冲区的数据立即写入套接字”是什么意思？ 写入套接字不就是写入套接字对应的发送缓冲区吗？ <a class="header-anchor" href="#强制将发送缓冲区的数据立即写入套接字-是什么意思-写入套接字不就是写入套接字对应的发送缓冲区吗" aria-label="Permalink to &quot;“强制将发送缓冲区的数据立即写入套接字”是什么意思？ 写入套接字不就是写入套接字对应的发送缓冲区吗？&quot;">​</a></h3><p>抱歉给你带来困惑。实际上，我给出的表述不够准确。</p><p>在Qt的QTcpSocket中，数据写入操作将数据放入套接字的发送缓冲区中，并且套接字会自动根据一些策略将缓冲区中的数据发送给对端。<code>write()</code> 和 <code>putChar()</code> 函数将数据写入发送缓冲区后，不会立即将数据发送出去，而是等待Qt的底层机制将数据从缓冲区发送出去。</p><p>而 <code>flush()</code> 函数的作用是将发送缓冲区中的数据立即强制发送出去，而不需要等待底层的自动发送机制。这个函数会阻塞当前线程，直到数据被真正发送给对端或者发送过程发生错误。</p><p>所以，正确的表述是 <code>flush()</code> 函数可以强制将发送缓冲区中的数据立即发送到对端，而不需要等待自动发送机制。这对于一些特定的场景，例如需要立即将数据发送到对端或确保数据实时到达等，可能会有一定的用处。</p><p>总结来说，写入套接字实际上是将数据放入发送缓冲区，而 <code>flush()</code> 函数则可以在需要时将缓冲区中的数据立即发送出去。</p><h1 class="p1" id="同步读写和异步读写" tabindex="-1">同步读写和异步读写 <a class="header-anchor" href="#同步读写和异步读写" aria-label="Permalink to &quot;同步读写和异步读写{.p1}&quot;">​</a></h1><p>异步读写和同步读写各有其优势和适用场景，不能一概而论哪种方式总是好于另一种方式。下面我将详细介绍两种方式的特点和适用场景。</p><ol><li><p>同步读写：</p><ul><li>特点：同步读写是指在进行读写操作时，程序会阻塞直到操作完成。也就是说，程序在读取或写入数据时会暂停执行，直到读取或写入操作完成后才继续执行后续代码。</li><li>优点： <ul><li>简单直观：同步读写的代码结构相对简单，易于理解和实现。</li><li>适用于简单的任务：当任务较为简单且性能要求不高时，同步读写可以提供足够的性能。</li></ul></li><li>缺点： <ul><li>阻塞：同步读写会阻塞主线程的执行，如果在同步读写时阻塞时间较长，可能会导致其他部分的程序响应较慢，降低用户体验。</li><li>效率低：由于同步读写需要等待操作完成才能继续执行后续代码，当需要处理大量的读写操作时，效率相对较低。</li></ul></li><li>适用场景： <ul><li>简单的任务：适用于需要进行简单操作，对性能要求不高，且不需要同时处理多个读写任务的场景。</li></ul></li></ul></li><li><p>异步读写：</p><ul><li>特点：异步读写是指在进行读写操作时，程序会继续执行后续代码，不会等待操作完成。</li><li>优点： <ul><li>非阻塞：异步读写不会阻塞主线程，可以在进行读写操作的同时继续执行其他代码，提高程序的响应性和并发性。</li><li>高效处理多个任务：异步读写适用于需要同时处理多个读写任务的场景，可以通过回调函数或事件循环等机制来处理多个异步操作。</li></ul></li><li>缺点： <ul><li>复杂性高：异步读写需要处理异步回调、事件循环等机制，代码结构和逻辑较为复杂，增加了开发和维护的难度。</li><li>容易出错：异步读写的代码逻辑较为复杂，容易出现各种并发相关的问题，如竞态条件、资源争用等。</li></ul></li><li>适用场景： <ul><li>高性能需求：适用于对性能要求较高且需要同时处理多个读写任务的场景，如网络通信、并发I/O操作等。</li><li>长时间耗时任务：适用于需要进行长时间耗时的读写任务，异步读写可以避免等待操作完成而导致的阻塞。</li></ul></li></ul></li></ol><p>综上所述，异步读写和同步读写各有其优势和适用场景，需要根据具体需求来选择合适的方式。在一些高并发、高性能要求的场景下，异步读写通常更为适用。而对于简单任务，同步读写可能更简单直观。</p><h1 class="p1" id="报错" tabindex="-1">报错 <a class="header-anchor" href="#报错" aria-label="Permalink to &quot;报错{.p1}&quot;">​</a></h1><h3 id="报错1" tabindex="-1">报错1 <a class="header-anchor" href="#报错1" aria-label="Permalink to &quot;报错1&quot;">​</a></h3><p><strong>QSocketNotifier: Socket notifiers cannot be enabled or disabled from another thread</strong></p><p>当你在Qt中遇到&quot;QSocketNotifier: Socket notifiers（通知） cannot be enabled or disabled from another thread&quot;错误时，这是因为你在一个线程中尝试在另一个线程上处理socket通知器。该错误是Qt的线程安全机制的结果。</p><p>Qt提供了线程安全的信号槽机制，允许在不同线程之间进行通信。然而，对于一些特殊的操作（如启用或禁用socket通知器），Qt要求在创建该对象的线程上执行相关操作。</p><p>解决此问题的一种方法是使用Qt的跨线程信号槽机制。以下是一个示例，展示了如何在不同线程之间启用或禁用socket通知器：</p><ol><li>创建一个新的QObject子类，用于处理socket通知：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QObject</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Q_OBJECT</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    explicit</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ~SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">public slots:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> enableSocketNotifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> disableSocketNotifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">signals:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> socketNotifierEnabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> socketNotifierDisabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QSocketNotifier </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socketNotifier;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ol start="2"><li>在构造函数中创建socket通知器：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(QObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parent)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parent)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> socketDescriptor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 设置socket描述符</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> socketType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ...;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 设置socket类型</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    socketNotifier </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QSocketNotifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socketDescriptor, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static_cast&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QSocketNotifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::Type</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socketType), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socketNotifier, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QSocketNotifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::activated, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::socketNotifierEnabled);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ol start="3"><li>实现启用和禁用socket通知的槽函数：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">enableSocketNotifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在创建socket通知的线程上启用socket通知</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    QMetaObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socketNotifier, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setEnabled&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Qt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::QueuedConnection, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Q_ARG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disableSocketNotifier</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在创建socket通知的线程上禁用socket通知</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    QMetaObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">invokeMethod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socketNotifier, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;setEnabled&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Qt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::QueuedConnection, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Q_ARG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">bool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上面的代码中，<code>QMetaObject::invokeMethod</code>的<code>Qt::QueuedConnection</code>参数确保了槽函数在所创建的线程上执行。</p><ol start="4"><li>在其他线程中接收socket通知的类中，连接到信号并在槽函数中处理：</li></ol><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OtherThreadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QObject</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Q_OBJECT</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    explicit</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OtherThreadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QObject</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nullptr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ~OtherThreadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">public slots:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleSocketNotifierEnabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    SocketNotifierHandler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">socketNotifierHandler;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OtherThreadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OtherThreadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(QObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">parent)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parent)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    socketNotifierHandler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(socketNotifierHandler, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">SocketNotifierHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::socketNotifierEnabled, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OtherThreadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::handleSocketNotifierEnabled);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OtherThreadClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handleSocketNotifierEnabled</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 在这里处理socket通知</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>通过上述步骤，在不同的线程中启用或禁用socket通知器，可以避免&quot;QSocketNotifier: Socket notifiers cannot be enabled or disabled from another thread&quot;错误。</p><h3 id="qsocketnotifier" tabindex="-1">QSocketNotifier <a class="header-anchor" href="#qsocketnotifier" aria-label="Permalink to &quot;QSocketNotifier&quot;">​</a></h3><p>在Qt中，<code>QSocketNotifier</code>是一个用于异步通知socket输入/输出状态变化的类。它可以监视一个套接字的读取状态、写入状态或异常状态，并在状态改变时发出相应的信号。</p><p><code>QSocketNotifier</code>类基于操作系统的文件描述符（通常是套接字）提供通知机制，可以在不阻塞线程的情况下检测套接字上的事件。它可以用于在GUI应用程序和非阻塞网络编程中监听套接字事件。</p><p>在使用<code>QSocketNotifier</code>时，可以创建一个<code>QSocketNotifier</code>对象，并指定要监听的套接字描述符及要监听的事件类型（读取、写入、异常）。然后，可以连接到相应的信号槽，以便在套接字状态发生变化时进行处理。</p><p><code>QSocketNotifier</code>提供以下三个信号：</p><ul><li><code>activated(int socket)</code>：当套接字上存在事件（如有数据可读、可写入或异常）时，会触发该信号。可以通过<code>socket</code>参数获取触发事件的套接字描述符。</li><li><code>activated(QSocketNotifier::Type)</code>：可以使用重载的信号，而不是使用套接字描述符，获取触发事件的类型（读取、写入或异常）。</li><li><code>destroyed(QObject* obj)</code>：当<code>QSocketNotifier</code>对象被销毁时，会触发该信号。</li></ul><p>注意，<code>QSocketNotifier</code>的对象创建在特定的线程中，其信号和槽函数也应该在同一线程中使用。</p><p>通过使用<code>QSocketNotifier</code>，可以实现对套接字的异步事件监听，例如在客户端或服务器中等待数据到达、可写入或异常状态变化，并及时做出响应。</p><h1 class="p1" id="线程无法共用一个socket" tabindex="-1">线程无法共用一个socket <a class="header-anchor" href="#线程无法共用一个socket" aria-label="Permalink to &quot;线程无法共用一个socket{.p1}&quot;">​</a></h1><p><strong>qt线程不能共用一个socket 保证线程安全 但是我还是希望一个线程跟服务端连接 一个线程和服务端发消息 一个线程和服务端发文件 一个线程和服务端打视频电话。这个怎么办</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>为了满足你的需求，在Qt中可以使用以下方法来实现不同线程与服务端进行连接、发送消息、发送文件以及打视频电话：</span></span>
<span class="line"><span></span></span>
<span class="line"><span>建立连接线程：创建一个单独的线程，用于在与服务端建立连接。在该线程中创建一个QTcpSocket对象，用于与服务端进行通信。你可以使用信号槽机制将连接状态发送给主线程或其他线程。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>消息发送线程：创建一个单独的线程，用于发送消息给服务端。在该线程中创建一个QTcpSocket对象，并使用它与服务端进行通信。可以通过信号槽机制将消息传递给线程进行处理。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>文件发送线程：创建一个单独的线程，用于发送文件给服务端。在该线程中创建一个QTcpSocket对象，并使用它与服务端进行通信。可以通过信号槽机制将文件传递给线程进行处理。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>视频电话线程：创建一个单独的线程，用于处理视频电话与服务端的通信。在该线程中创建一个QTcpSocket对象，并使用它与服务端进行通信。可以通过信号槽机制传递视频流给线程进行处理，可以使用一些现成的库或协议来实现视频通话功能。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>使用这些单独的线程和各自的QTcpSocket对象，你可以实现在每个线程中独立与服务端进行通信的能力。通过使用信号槽机制，你可以在不同线程之间进行数据传递和处理。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>值得注意的是，虽然每个线程都有自己的QTcpSocket对象进行通信，但你需要确保在访问这些对象时遵守线程安全的操作。你可以使用互斥量（QMutex）或其他线程同步机制来确保在多个线程之间正确地访问和操作这些socket对象。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>需要注意的是，Qt中的多线程通信需要小心设计线程之间的交叉引用以及对象的生命周期管理，避免潜在的资源竞争和内存泄漏问题。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>意思是说我一个客户端要开很多个socket和服务端连接 才能实现以上功能了？</strong></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>是的，为了实现以上功能，你可能需要在客户端使用多个Socket对象来与服务端建立多个连接。每个功能对应一个独立的Socket对象。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>举例来说，你可以创建一个连接线程，在该线程中创建一个QTcpSocket对象，用于与服务端建立连接。该Socket对象将负责处理建立连接的细节。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>接下来，对于每个功能，如发送消息、发送文件和打视频电话，你可以分别创建单独的线程，在每个线程中创建一个独立的QTcpSocket对象来实现与服务端的通信。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>这样，每个功能对应一个独立的Socket对象，它们分别在各自的线程中进行处理。这样可以实现并发的功能操作，并确保线程安全。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>请注意，每个Socket对象都需要独立管理连接、发送和接收数据等操作。你还需要处理线程之间的数据传递和同步。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>为了保持代码的可管理性和可扩展性，你可以使用Qt的信号槽机制和事件循环来进行线程间的通信。从一个线程中发出的信号可以连接到另一个线程中的槽函数，实现数据的传递和操作。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>另外，确保在多线程环境中正确地管理资源是非常重要的。你可以使用互斥量（QMutex）或其他线程同步机制来确保在不同线程之间正确地访问和操作Socket对象。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>综上所述，为了实现不同功能的并发操作，并确保线程安全，你可能需要在客户端中使用多个Socket对象来与服务端建立多个连接，并在各自的线程中处理不同的功能操作。使用信号槽机制和线程同步机制，你可以实现数据的传递和操作，并确保线程安全。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h1 class="p1" id="udp协议-1" tabindex="-1">UDP协议 <a class="header-anchor" href="#udp协议-1" aria-label="Permalink to &quot;UDP协议{.p1}&quot;">​</a></h1><div class="language-apl vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">apl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UDP（User Datagram Protocol）是运输层协议之一，它是一种无连接的协议，提供了数据报传输服务。相比于TCP协议，UDP协议更加简洁和轻量，但也因此缺少了可靠性和流量控制的特性。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UDP协议的特点如下：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 无连接：UDP不需要在通信之前建立连接，发送方只需将数据报文发送给接收方即可。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 不可靠：UDP协议不保证数据报文的可靠性传输，因此数据报文可能会丢失、重复或乱序。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 快速：由于不需要建立连接和维护状态等操作，UDP的开销较小，因此传输速度更快。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 面向报文：UDP将应用层的数据封装为UDP数据报进行传输，每个UDP数据报都是完整的、独立的单元。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">UDP协议的应用场景如下：</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 实时性要求高的应用：UDP适用于对实时性要求较高的应用，例如音视频传输、在线游戏等。尽管可能会出现丢包的情况，但由于UDP的快速传输和较低的延迟，可以确保实时性要求的满足。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 不需要可靠性的应用：对于一些不需要可靠传输的应用，例如DNS解析、SNMP等，使用UDP能够减少开销并提高传输效率。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 广播和多播应用：UDP支持广播和多播，可以将数据报文发送给多个主机，以满足一对多的通信需求。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 简单的应用：对于一些简单的应用，例如网络时间协议（NTP）、唤醒局域网上的设备等，由于请求和响应的报文较小且实时性要求较高，使用UDP能够更快速地完成通信。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">总的来说，UDP协议虽然不具备可靠性和流量控制的特性，但因为其简洁和快速的特点，适用于一些对实时性要求高、不需要可靠性传输的应用场景。</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><h1 class="p1" id="简单upd服务器" tabindex="-1">简单upd服务器 <a class="header-anchor" href="#简单upd服务器" aria-label="Permalink to &quot;简单upd服务器{.p1}&quot;">​</a></h1><p>当使用C++的Qt库编写UDP服务端时，可以使用QUdpSocket类来实现。下面是一个简单的示例代码：</p><p>首先，在Qt项目中包含以下头文件：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;QtNetwork&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>然后，在服务端类中创建一个QUdpSocket对象：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QUdpSocket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">udpSocket;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>接下来，我们需要在服务端类的构造函数中初始化和绑定socket：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">udpSocket </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QUdpSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">udpSocket-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QHostAddress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::Any, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1234</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 绑定本地地址和端口号</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>接着，可以通过连接readyRead()信号来监听接收到的数据：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(udpSocket, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QUdpSocket</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::readyRead, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::receiveData);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在receiveData()槽函数中，处理接收到的数据：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Server</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">receiveData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (udpSocket-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasPendingDatagrams</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 处理所有待处理的数据报</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        QByteArray datagram;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        datagram.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(udpSocket-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pendingDatagramSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        QHostAddress sender;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        quint16 senderPort;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        udpSocket-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readDatagram</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(datagram.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), datagram.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sender, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">senderPort);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 读取数据报</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 在这里进行数据处理</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>最后，记得在主函数中实例化并运行服务端对象：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QCoreApplication </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(argc, argv);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Server server;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>上述代码中的Server类是自定义的UDP服务端类，可以根据实际需求进行扩展和添加其他功能。</p><p>以上是一个简单的UDP服务端示例代码，用于接收并处理来自客户端的数据。你可以根据自己的需求进一步完善和修改。请注意，这只是一个简单的示例，实际场景中可能需要处理更多的错误处理和异常情况。</p><h1 class="p1" id="字节序处理" tabindex="-1">字节序处理 <a class="header-anchor" href="#字节序处理" aria-label="Permalink to &quot;字节序处理{.p1}&quot;">​</a></h1><p>在Qt的UDP网络编程中，Qt提供了一些用于字节序转换的函数，你可以使用这些函数将QByteArray转换为对应的字节序。下面是一个将QByteArray转换为网络字节序（大端字节序）的示例：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QByteArray byteArray;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //假设这是你要转换的QByteArray</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将QByteArray转换为网络字节序</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QDataStream</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> stream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">byteArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QIODevice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ReadOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setByteOrder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QDataStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::BigEndian);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">quint32 value;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //用于存储转换后的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stream </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出结果</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">qDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;转换后的值：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上述示例中，我们使用了QDataStream类，它提供了用于读写二进制数据的功能。通过将QByteArray传递给QDataStream的构造函数，并使用setByteOrder函数设置字节序为大端字节序（网络字节序），我们可以将数据转换为对应的字节序。然后使用&gt;&gt;运算符将转换后的值存储在quint32类型的变量value中。</p><p>你也可以将字节序设置为小端字节序（主机字节序），你只需要将setByteOrder函数的参数改为QDataStream::LittleEndian即可：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setByteOrder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QDataStream</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::LittleEndian);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样，QByteArray就会被转换为小端字节序。</p><p>希望这个回答对你有帮助，如果还有其他问题，请随时提问。</p><p>在C++的Qt中，可以使用<code>QSysInfo</code>类来获取本机的字节序信息。<code>QSysInfo</code>提供了一些静态函数用于获取系统信息，包括字节序。</p><p>以下是如何在Qt中获取本机字节序的详细步骤：</p><div class="language-cpp vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;QCoreApplication&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;QDebug&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &lt;QSysInfo&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> argc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">argv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[])</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    QCoreApplication </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(argc, argv);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 获取本机字节序</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    QSysInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::Endian endianness </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QSysInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::ByteOrder;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (endianness </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QSysInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::BigEndian) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        qDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;本机字节序：大端字节序 (网络字节序)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (endianness </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> QSysInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">::LittleEndian) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        qDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;本机字节序：小端字节序 (主机字节序)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        qDebug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;&lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;无法确定本机字节序&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">exec</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>在上述示例中，我们使用了<code>QSysInfo::ByteOrder</code>来获取本机的字节序信息，然后通过判断得到的信息是大端字节序还是小端字节序，来打印对应的结果。</p><p>编译并运行上述代码后，将会根据本机的字节序输出相应的信息。</p><p>希望这个回答解决了你的问题。如果你还有其他疑问，请随时提问。</p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-d4a0bba5><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-d4a0bba5><span class="visually-hidden" id="doc-footer-aria-label" data-v-d4a0bba5>Pager</span><div class="pager" data-v-d4a0bba5><!----></div><div class="pager" data-v-d4a0bba5><a class="VPLink link pager-link next" href="/Blog/QT/QT%E5%9F%BA%E7%A1%80/QSS%E7%AC%94%E8%AE%B0.html" data-v-d4a0bba5><!--[--><span class="desc" data-v-d4a0bba5>Next page</span><span class="title" data-v-d4a0bba5>QSS笔记</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-5d98c3a5 data-v-e315a0ad><div class="container" data-v-e315a0ad><p class="message" data-v-e315a0ad>学 习 记 录</p><p class="copyright" data-v-e315a0ad>Copyright © 2024 by Cookie330</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"c___基础demo_四次挥手.md\":\"Bl1mIjBr\",\"c___基础demo_模板可变参数列表.md\":\"CIM4VlVM\",\"git_index.md\":\"B7_ahRrS\",\"c___asio_websocket.md\":\"Cf37GfAE\",\"c___asio_http.md\":\"vJIQ0I9E\",\"c___基础demo_cmakelist.txt.md\":\"DmhNukF0\",\"c___基础demo_万能引用.md\":\"BrFypstx\",\"c___protobuf序列化.md\":\"BXQeUbVB\",\"c___grpc.md\":\"BBdZYxEl\",\"qt_qt基础_qt窗口.md\":\"CvYAOpJs\",\"qt_qt代码_sqlite增删改查.md\":\"8iny-tp7\",\"qt_qt代码_excel处理.md\":\"Df25Lj_2\",\"qt_qt基础_qt机制.md\":\"BXNGMugi\",\"c___openssl.md\":\"5cF8uIgW\",\"c___基础demo_dag.md\":\"DGiDQZtE\",\"c___基础demo_实现share_ptr智能指针.md\":\"BElFQQcY\",\"qt_qt代码_日志界面.md\":\"BODKiM8w\",\"index.md\":\"B5GVGxxu\",\"c___基础demo_自制c__连接redis.md\":\"CeGR4Lwy\",\"git_git常用命令.md\":\"DZevOojr\",\"c___基础demo_线程池.md\":\"CNdZQkul\",\"qt_qt基础_qt网络.md\":\"CmrK3xzE\",\"c___动态链接库.md\":\"B1qlfbMp\",\"c___基础demo_推箱子.md\":\"DE4A8baJ\",\"qt_qt基础_qss笔记.md\":\"CBRNJ61R\",\"c___asio_asynctcpserver.md\":\"XR925HaE\",\"qt_qt代码_发布订阅.md\":\"BFDNzbBv\",\"qt_qt基础_qt多线程.md\":\"C41QqKC5\",\"qt_qt代码_日志类.md\":\"CzEo2gC7\",\"qt_qt基础_qt类.md\":\"C2kKg4f5\",\"c___数据结构算法.md\":\"F-Mmkyj7\",\"qt_qt代码_自制wireshark.md\":\"GEsvyyeF\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"我的笔记\",\"description\":\"A VitePress Site\",\"base\":\"/Blog/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"search\":{\"provider\":\"local\"},\"footer\":{\"message\":\"学 习 记 录\",\"copyright\":\"Copyright © 2024 by Cookie330\"},\"nav\":[{\"text\":\"C++\",\"link\":\"/C++/OpenSSL.md\"},{\"text\":\"Python\",\"link\":\"-\"},{\"text\":\"Go\",\"link\":\"-\"},{\"text\":\"QT\",\"items\":[{\"text\":\"QT基础\",\"link\":\"/QT/QT基础/qt网络.md\"},{\"text\":\"QT代码\",\"link\":\"/QT/QT代码/发布订阅.md\"}]},{\"text\":\"Git\",\"link\":\"/Git/git常用命令.md\"},{\"text\":\"链接\",\"items\":[{\"text\":\"vitepress官网\",\"link\":\"https://vitepress.dev/zh\"},{\"text\":\"OpenAi官网\",\"link\":\"https://chat.openai.com/\"},{\"text\":\"力扣官网\",\"link\":\"https://leetcode.cn/problemset/\"},{\"text\":\"恋恋风晨zack博客\",\"link\":\"https://llfc.club/\"},{\"text\":\"Godbolt\",\"link\":\"https://godbolt.org/\"}]}],\"outline\":{\"level\":[1,6],\"label\":\"页面导航\"},\"sidebar\":{\"/C++/\":{\"text\":\"c++\",\"items\":[{\"text\":\"基础Demo\",\"collapsed\":true,\"items\":[{\"text\":\"模板可变参数列表\",\"link\":\"/C++/基础demo/模板可变参数列表.md\"},{\"text\":\"实现share_ptr智能指针\",\"link\":\"/C++/基础demo/实现share_ptr智能指针.md\"},{\"text\":\"推箱子\",\"link\":\"/C++/基础demo/推箱子.md\"},{\"text\":\"万能引用\",\"link\":\"/C++/基础demo/万能引用.md\"},{\"text\":\"线程池\",\"link\":\"/C++/基础demo/线程池.md\"},{\"text\":\"自制C++连接redis\",\"link\":\"/C++/基础demo/自制C++连接redis.md\"},{\"text\":\"DAG\",\"link\":\"/C++/基础demo/DAG.md\"},{\"text\":\"CmakeList.txt\",\"link\":\"/C++/基础demo/CmakeList.txt.md\"},{\"text\":\"四次挥手\",\"link\":\"/C++/基础demo/四次挥手.md\"}]},{\"text\":\"boost::asio\",\"collapsed\":true,\"items\":[{\"text\":\"  AsyncTcpServer\",\"link\":\"/C++/asio/AsyncTcpServer.md\"},{\"text\":\"  http\",\"link\":\"/C++/asio/http.md\"},{\"text\":\"  websocket\",\"link\":\"/C++/asio/websocket.md\"}]},{\"text\":\"OpenSSL\",\"link\":\"/C++/OpenSSL.md\"},{\"text\":\"数据结构算法\",\"link\":\"/C++/数据结构算法.md\"},{\"text\":\"动态链接库\",\"link\":\"/C++/动态链接库.md\"},{\"text\":\"protobuf序列化\",\"link\":\"/C++/protobuf序列化.md\"},{\"text\":\"grpc\",\"link\":\"/C++/grpc.md\"}]},\"/Python/\":{\"text\":\"Python\"},\"/Go/\":{\"text\":\"Go\"},\"/QT/QT基础/\":{\"text\":\"qt基础\",\"items\":[{\"text\":\"QT网络\",\"link\":\"/QT/QT基础/qt网络.md\"},{\"text\":\"QSS笔记\",\"link\":\"/QT/QT基础/QSS笔记.md\"},{\"text\":\"QT窗口\",\"link\":\"/QT/QT基础/qt窗口.md\"},{\"text\":\"QT多线程\",\"link\":\"/QT/QT基础/qt多线程.md\"},{\"text\":\"QT机制\",\"link\":\"/QT/QT基础/qt机制.md\"},{\"text\":\"QT类\",\"link\":\"/QT/QT基础/qt类.md\"}]},\"/QT/QT代码/\":{\"text\":\"qt代码\",\"items\":[{\"text\":\"发布订阅\",\"link\":\"/QT/QT代码/发布订阅.md\"},{\"text\":\"日志类\",\"link\":\"/QT/QT代码/日志类.md\"},{\"text\":\"日志界面\",\"link\":\"/QT/QT代码/日志界面.md\"},{\"text\":\"系统资源统计\",\"link\":\"/QT/QT代码/index.md\"},{\"text\":\"EXCEL处理\",\"link\":\"/QT/QT代码/EXCEL处理.md\"},{\"text\":\"自制wireshark\",\"link\":\"/QT/QT代码/自制wireshark.md\"},{\"text\":\"sqlite增删改查\",\"link\":\"/QT/QT代码/sqlite增删改查.md\"}]},\"/Git/\":{\"text\":\"git\",\"items\":[{\"text\":\"git常用命令\",\"link\":\"/Git/git常用命令.md\"}]}},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Cookie330/Blog\"}]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>